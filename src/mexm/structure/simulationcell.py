from copy import copy, deepcopy
import numpy as np
import numpy.linalg as linalg
import ase

from mexm.util import is_number
from mexm.exception import MexmException
from mexm.structure import Atom
from mexm.structure import Lattice

class MexmBadAtomicPosition(MexmException): pass

def convert_coordinates(position, lattice, src_type='cartesian', dst_type='direct'):
    assert isinstance(position, list) or isinstance(position, np.ndarray)
    assert isinstance(lattice, Lattice)
    assert src_type in ['cartesian', 'direct']
    assert dst_type in ['cartesian', 'direct']

    if isinstance(position, list):
        position_ = np.ndarray(position)
    elif isinstance(position, np.ndarray):
        position_ = np.copy(position)
    else:
        raise TypeError

    new_position = None
    if src_type == 'direct' and dst_type == 'cartesian':
        a1 = lattice.a1
        a2 = lattice.a2
        a3 = lattice.a3

        new_position = position[0] * a1 + position[1] * a2 + position[2] * a3
    elif src_type == 'cartesian' and dst_type == 'direct':
        H = lattice.a0 * lattice.H
        new_position = np.dot(linalg.inv(H), position)
    elif src_type == dst_type:
        new_position = np.copy()
    else:
        raise ValueError(
            "cannot convert from {} to {}".format(src_type, dst_type)
        )

    assert isinstance(new_position, np.ndarray)
    return new_position

class SimulationCell(object):
    ptol = 1e-8
    """A structural representation of a material system

    A structural system consists of a vector of lattice vector which forms the
    boundaries of the simulation cell, and an atomic basis of atoms defined in
    the direct coordinates of the lattice vectors.

    Args:
        obj (optional): if this argument is set then the this constructor acts
            as a copy constructor.  Will takse :obj:`ase.atoms.Atoms` and

    Attributes:
        comment (str): a descriptive description of the crystal structure
        lattice (mexm.structure.Lattice): the crystal structure of the lattice
        atomic_basis (:obj:`list` of :obj:`pypospack.crystallography.Atoms`): a list
            of atoms contained within the crystal structure.
        vacancies (:obj:`list` of :obj:`mexm.structure.Atoms`): a
            list of vacancy sites contained within the crystal structure.
        interstitials (:obj:`list` of :obj:`mexm.structure.Atoms`): a
            list of interstitial sites contained within the crystal structure.

    """

    def __init__(self):
        self.comment = "generated by pypospack"
        self.lattice = Lattice()
        self.atomic_basis = []
        self.vacancies = []
        self.interstitials = []


    @classmethod
    def initialize_from_object(cls, obj):

        if isinstance(obj, ase.atoms.Atoms):
            simulation_cell = cls.initialize_from_ase(obj)
        elif isinstance(obj, SimulationCell):
            simulation_cell = cls.initialize_from_mexm(obj)
        else:
            raise TypeError(
                "{} is not a supported structure object for initialization".format(
                    str(type(obj))
                )
            )

        return simulation_cell

    @classmethod
    def initialize_from_mexm(cls, obj):
        """ copy constructor from mexm """
        assert isinstance(obj, SimulationCell)
        o = cls()
        o.comment = obj.comment
        o.lattice.a0 = obj.lattice.a0
        o.lattice.H = deepcopy(obj.lattice.H)
        o.atomic_basis = deepcopy(obj.atomic_basis)
        return o

    @staticmethod
    def initialize_from_ase(obj):
        """ copy constructor for ase atoms objects """
        assert isinstance(obj, ase.atoms.Atoms)
        o = SimulationCell()
        o.comment = "generated by pypospack from ase"
        o.lattice.a0 = 1.0
        o.lattice.H = obj.cell

        # populate atomic basis
        for atom in obj:
            kwargs = {
                'position':atom.position,
                'lattice':o.lattice,
                'src_type':'cartesian',
                'dst_type':'direct'
            }
            position = convert_coordinates(**kwargs)
            #  insure position is within the cell
            for i in range(3):
                if position[i] < 0:
                    position[i] = 1 + position[i]

            o.add_atom(symbol=atom.symbol, position=position)
        return o

    def to_dict(self):
        return {
            'comment':self.comment,
            'lattice':self.lattice.to_dict(),
            'atomic_basis':self.atomic_basis,
            'vacancies':self.vacancies,
            'interstitials':self.interstitials
        }

    @property
    def volume(self) -> float:
        """ volume is calculate from the scalar triple product """

        a1 = self.lattice.a1
        a2 = self.lattice.a2
        a3 = self.lattice.a3

        volume = np.dot(np.cross(a1, a2), a3)


    @property
    def H(self):
        return self.lattice.H

    @H.setter
    def H(self, H):
        self.lattice.H = H

    @property
    def a0(self):
        return self.lattice.a0

    @a0.setter
    def a0(self, a0):
        assert is_number(a0)
        self.lattice.a0 = a0

    @property
    def h1(self):
        """numpy.ndarray: which is the a1 lattice vector"""
        return self.lattice.h1

    @h1.setter
    def h1(self, h1):
        """numpy.array: this is the h1 component of the H matrix"""
        if isinstance(h1, list):
            self.lattice.h1 = np.array(h1)
        elif isinstance(h1, np.ndarray):
            self.lattice.h1 = np.copy(h1)

    @property
    def h2(self):
        """numpy.array: which is the a2 lattice vector"""
        return self.lattice.h2

    @h2.setter
    def h2(self, h2):
        """numpy.array: this is the h2 component of the H matrix"""
        if isinstance(h2, list):
            self.lattice.h2 = np.array(h2)
        elif isinstance(h2, np.ndarray):
            self.lattice.h2 = np.copy(h2)

    @property
    def h3(self):
        """numpy.array: this is the a3 lattice vector"""
        return self.lattice.h3

    @h3.setter
    def h3(self, h3):
        """numpy.array: this is the h3 component of the H matrix"""
        if isinstance(h3, list):
            self.lattice.h3 = np.array(h3)
        elif isinstance(h3, np.ndarray):
            self.lattice.h3 = np.copy(h3)

    @property
    def a1(self):
        return self.lattice.a1

    @property
    def a2(self):
        return self.lattice.a2

    @property
    def a3(self):
        return self.lattice.a3


    @property
    def a1_length(self):
        """float: the length of h1 lattice vector"""
        return self.lattice.a1_length

    @property
    def a2_length(self):
        """float: the length of the h2 lattice vector"""
        return self.lattice.a2_length

    @property
    def a3_length(self):
        """float: the length of the h3 lattice vector"""
        return self.lattice.a3_length

    @property
    def b1(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        return self.lattice.b1

    @property
    def b2(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        return self.lattice.b2

    @property
    def b3(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        return self.lattice.b3

    @property
    def n_atoms(self):
        """float: the number of atoms in the structure"""
        n_atoms = len(self.atomic_basis)
        return n_atoms

    @property
    def symbols(self):
        """list of str: a list of the symbols in the structure"""

        symbols = list(set([a.symbol for a in self.atomic_basis+self.interstitials]))
        return symbols

    def check_if_atom_exists_at_position(self, symbol, position):
        """determines if there is an atom at a position

        This code looks for atoms in the list of atoms in the atomic_basis.

        Returns:
            tuple: The first element if true in an atom exists at the location,
                False if it doesn't exist.   The second element is an int which
                indicates the index of the atom at that position.  The index is
                negative if it is the list of interstitials.
        """

        return_value = (False,None)
        # check to see if atom exists in the atomic basis
        for i,a in enumerate(self.atomic_basis):
            diff = [abs(position[i]-a.position[i]) for i in range(3)]
            if max(diff) < self.ptol:
                return_value = (True,i)

        return return_value

    def find_atom_at_position(self, position, ptol=1e-3):
        """find atom at position

        Args:
        """

        if isinstance(position, list):
            position_ = np.array(position)
        elif isinstance(position, np.ndarray):
            position_ = np.copy(position)
        else:
            raise TypeError(
                "position must either by a numpy array or a list"
            )

        for i, atom in enumerate(self.atomic_basis):
            diff = atom.position - position_
            diff_distance = self.a0 * np.dot(diff, diff)**0.5
            if diff_distance < ptol:
                return i
        return None

    def add_atom(self, symbol, position, atom_id=None, magmom=0.):
        """add an atom to the structure

        Checks to see if an existing atom exists at the position we are trying
        to add an atom, then if the position is empty.  The atom is added then
        added to the list of interstitials.

        Args:
            symbol (str): the symbol of the atom to be added
            position (list): the position of the atom to be added
            magmom (float): magnetic moment of the atom

        Raises:
            ValueError: If an atom already exists in the position.
        """

        if self.find_atom_at_position(position) is None:
            atom_id = '{}{}'.format(
                symbol,
                int(sum([k.symbol==symbol for k in self.atomic_basis]))
            )
            self.atomic_basis.append(
                Atom(atom_id=atom_id,
                     symbol=symbol,
                     position=position,
                     magmom=magmom
                )
            )

        else:
            msg = "Tried to add {} @ {} an atom already there\n".format(
                    symbol,
                    position
            )
            raise ValueError(msg)

    def remove_atom(self, symbol, position):
        """ remove an atom from the structure

        This method checks for atom at the position, if an atom exists.  It is
        removed from the structure then the position is recorded as a vacancy.

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom

        """
        ptol = 1e-3
        for i,a in enumerate(self.atomic_basis):
            if (a.symbol == symbol):
                diff = [abs(position[j]-a.position[j]) for j in range(3)]
                if all([k < self.ptol for k in diff]):
                    del self.atomic_basis[i]
                    return
        err_msg = "Tried to remove {} @ {}, no atom found"
        err_msg = err_msg.format(symbol,position)
        raise ValueError(err_msg)

    def add_interstitial(self, symbol, position):
        """ add an interstitial to the atomic basis

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom
        """
        self.add_atom(symbol,position)
        self.interstitials.append([symbol,position])

    def add_vacancy(self, symbol, position):
        """ create a vacancy

        Creates a vacancy by removing an atom from the atomic basis

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom
        """
        self.remove_atom(symbol,position)
        self.vacancies.append([symbol,position])

    def get_number_of_atoms(self, symbol=None):
        """ get the number of atoms in the simulation cell

        Args:
           symbol (str): by default, the total number of atoms in the
               simulation cell is returns.  If a symbol is provided, then the
               the number atoms for that symbol is returned.
        Returns:
           (int): the number of atoms
        """
        if symbol is None:
            return len(self.atomic_basis)
        else:
            n_atoms = 0
            for atom in self.atomic_basis:
                if (atom.symbol == symbol):
                    n_atoms += 1
            return n_atoms

    def normalize_h_matrix(self):
        # change the h_matrix where the lattice parameter is 1.0
        lattice_real_space = Lattice(
            a0 = 1.0,
            H = self.lattice.H * self.lattice_a0
        )

        self.lattice = Lattice(
            a0 = lattice_real_space.a1,
            H = lattice_real_space.H / lattice_real_space.a1
        )

    def atomic_basis_to_string(self):
        # print atomic basis
        str_n_cols = 5
        str_atomic_basis_header_fmt = "{:10}   {:10} {:10} {:10} {:10}\n"
        str_atomic_basis_row_fmt = "{:10} {:10.6f} {:10.6f} {:10.6f} {:10.6f}\n"

        str_out = "ATOMIC BASIS:\n"
        str_out += str_atomic_basis_header_fmt.format('symbol','x','y','z','magmom')
        for a in self.atomic_basis:
            str_out += str_atomic_basis_row_fmt.format(
                a.symbol,
                a.position[0],
                a.position[1],
                a.position[2],
                a.magnetic_moment)
        return str_out

    def vacancies_to_string(self):
        str_out = "VACANCIES"
        if self.vacancies == []:
            return ""
        else:
            str_out = ""
            return str_out

    def interstitials_to_string(self):
        str_out = "INTERSTIALS"
        if self.interstitials == []:
            return ""
        else:
            str_out = ""
            return str_out

    def lattice_to_string(self):
        return self.lattice.__str__()

    def __str__(self):
        str_out = self.lattice_to_string() + "\n"
        str_out += self.atomic_basis_to_string()
        str_out += self.vacancies_to_string()
        str_out += self.interstitials_to_string()
        return str_out
