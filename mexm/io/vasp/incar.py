import os, shutil, pathlib
import re
import copy
import numpy as np
from collections import OrderedDict

class VaspIncarError(Exception):
    def __init__(self,*args,**kwargs):
        """Error class for reading/writing VASP INCAR IO issues """
        Exception.__init__(self,*args,**kwargs)


class Incar(object):

    def __init__(self, filename="INCAR"):
        """ object for dealing with input and output to VASP via INCAR file

        Args:
        filename (str): the filename of the INCAR file, default:'INCAR'
        """
        self.filename = filename

        self._fmt_section = '# {:*^78}\n'
        self._fmt_arg = '{:<30}! {}\n'
        self._cmt_dict = None
        #self._cmt_dict = initialize_incar_comments()

        # default initialization of INCAR file
        self.system = 'automatically generated by mexm'
        self.__init_start_info()
        self.__init_density_of_states()
        self.__init_symmetry()
        self.__init_scf()
        self.__init_spin()
        self.__init_mixer()
        self.__init_ionic_relaxation()
        self.__init_output()

    def __init_start_info(self):
        self.istart=0
        self.icharg=0

    def __init_density_of_states(self):
        self.ismear=0
        self.sigma=0.2

    def __init_symmetry(self):
        self.isym = 2
        self.symprec = 1e-4

    def __init_scf(self):
        self.ediff = 1e-6 # convergece criteria in eV
        self.nelm = 40 # maximum number of SCF steps
        self.encut = 400 # energy cutoff
        self.prec = 'High'  # set avoid anti-aliasing errors
        self.lreal = 'False' # real space projectors are less accurate
        self.algo = 'Normal' # most robust operator

    def __init_spin(self):
        self.ispin=1
        self.lorbit=None
        self.rwigs=None
        self.magmom=None

    def __init_mixer(self):
        self.amix = None
        self.bmix = None
        self.amix_mag = None
        self.bmix_mag = None

    def __init_ionic_relaxation(self):
        self.ibrion = None
        self.isif = None
        self.ediffg = None
        self.nsw = None
        self.potim = None

    def __init_output(self):
        self.lwave = False
        self.lcharg = False
        self.lvtot = False

    @property
    def is_continue_job(self):
        "bool: True if continuation job"
        if self.istart != 0 or self.icharg!=0:
            return True
        else:
            return False

    def get_section_string(self, comment):
        str_out = '# {:*^78}\n'.format(comment)
        return str_out

    def get_option_string(self, option_flag, option_value):
        try:
            option_comment = self._cmt_dict[option_flag][option_value]
            str_out = '{:<30}! {}\n'.format(
                "{} = {}".format(option_flag, option_value),
                option_comment
            )
        except KeyError as e:
            str_out = '{} = {}\n'.format(option_flag, option_value)
        return str_out


    def write(self,filename=None):
        """write poscar file

        Args:
        filename (str): the filename of the poscar file,
        """

        if filename is not None:
           self.filename = filename
        f = open(self.filename,'w')
        f.write(self.to_string())
        f.close()

    def read(self,fname=None):
        if fname is not None:
            self.filename = fname
        f = open(self.filename)
        for line in f:
            if line.startswith('#'):
                # ignore comments
                pass
            elif line.strip() == '':
                # ignore blank lines
                pass
            else:
                args = [ line.strip().split('!')[0].split('=')[0].strip(),
                         line.strip().split('!')[0].split('=')[1].strip() ]
                if args[0] == 'ISTART':
                    self.istart = int(args[1])
                elif args[0] == 'ICHARG':
                    self.icharg = int(args[1])
                elif args[0] == 'ISPIN':
                    self.ispin = int(args[1])
                elif args[0] == 'MAGMOM':
                    self.magmom = args[1]
                elif args[0] == 'ISMEAR':
                    self.ismear = int(args[1])
                elif args[0] == 'SIGMA':
                    self.sigma = float(args[1])
                elif args[0] == 'ALGO':
                    self.algo = args[1]
                elif args[0] == 'EDIFF':
                    self.ediff = float(args[1])
                elif args[0] == 'ENCUT':
                    self.encut = float(args[1])
                elif args[0] == 'NELM':
                    self.nelm == int(args[1])
                elif args[0] == 'PREC':
                    self.prec = args[1]
                elif args[0] == 'EDIFFG':
                    self.ediffg = float(args[1])
                elif args[0] == 'IBRION':
                    self.ibrion = int(args[1])
                elif args[0] == 'ISIF':
                    self.isif = int(args[1])
                elif args[0] == 'POTIM':
                    self.potim = float(args[1])
                elif args[0] == 'NSW':
                    self.nsw = int(args[1])
                elif args[0] == 'SYSTEM':
                    self.system = args[1]
                elif args[0] == 'LWAVE':
                    self.lwave = args[1]
                elif args[0] == 'LCHARG':
                    self.lcharg = args[1]
                elif args[0] == 'LORBIT':
                    self.lorbit = int(args[1])
                elif args[0] == 'LVTOT':
                    self.lvtot = args[1]
                elif args[0] == 'LREAL':
                    self.lreal = args[1]
                elif args[0] == 'MAGMOM':
                    self.magmom = args[1]
                elif args[0] == 'ISYM':
                    self.isym = int(args[1])
                elif args[0] == 'SYMPREC':
                    self.symprec = float(args[1])
                elif args[0] == 'RWIGS':
                    self.rwigs = float(rwigs)
                elif args[0] == 'NPAR':
                    self.npar = int(args[1])
                elif args[0] == "AMIX":
                    self.amix = float(args[1])
                elif args[0] == 'BMIX':
                    self.bmix = float(args[1])
                elif args[0] == 'AMIX_MAG':
                    self.amix_mag = float(args[1])
                elif args[1] == 'BMIX_MAG':
                    self.bmix_mag = float(args[1])
                else:
                    err_msg = "pypospack does not support tag {}".format(args[0])
                    raise VaspIncarError(err_msg)

    def set_no_ionic_relaxation(self):
        self.ibrion = None
        self.isif = None

    def to_string(self):
        str_out = ''
        str_out += self.__system_information_to_string()
        str_out += self.__start_information_to_string()
        str_out += self.__dos_information_to_string()
        str_out += self.__sym_information_to_string()
        str_out += self.__scf_information_to_string()
        str_out += self.__spin_polarization_to_string()
        str_out += self._mixer_to_string()
        str_out += self.__ionic_relaxation_to_string()
        str_out += self.__output_configuration_to_string()
        return str_out

    def _mixer_to_string(self):

        mixing_tags = [self.amix, self.bmix, self.amix_mag, self.bmix_mag]
        if all([k is None for k in mixing_tags]):
            return ""
        else:
            str_out = self.get_section_string("MIXING")
            if self.amix is not None:
                str_out += self.get_option_string('AMIX',self.amix)
            if self.bmix is not None:
                str_out += self.get_option_string('BMIX',self.bmix)
            if self.amix_mag is not None:
                str_out += self.get_option_string('AMIX_MAG', self.amix_mag)
            if self.bmix_mag is not None:
                str_out += self.get_option_string('BMIX_MAG', self.bmix_mag)
            return str_out
    def __system_information_to_string(self):
        str_out = "SYSTEM = {}\n\n".format(self.system)
        return str_out

    def __start_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('STARTING INFORMATION')
        str_out += self._fmt_arg.format(fmt.format('ISTART',self.istart),self._cmt_dict['ISTART'][self.istart])
        str_out += self._fmt_arg.format(fmt.format('ICHARG',self.icharg),self._cmt_dict['ICHARG'][self.icharg])
        str_out += "\n"
        return str_out

    def __dos_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('DENSITY OF STATES')
        str_out += self._fmt_arg.format(fmt.format('ISMEAR',self.ismear),self._cmt_dict['ISMEAR'][self.ismear])
        str_out += self._fmt_arg.format(fmt.format('SIGMA',self.sigma),self._cmt_dict['SIGMA'])
        str_out += "\n"
        return str_out

    def __sym_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('SYMMETRY')
        str_out += self._fmt_arg.format(fmt.format('ISYM',self.isym),self._cmt_dict['ISYM'][self.isym])
        str_out += self._fmt_arg.format(fmt.format('SYMPREC',self.symprec),self._cmt_dict['SYMPREC'])
        str_out += "\n"
        return str_out


    def __scf_information_to_string(self):
        fmt = "{} = {}"
        if self.algo.startswith('N'):
            self.algo = 'Normal'
        elif self.algo.startswith('V'):
            self.algo = 'VeryFast'
        elif self.algo.startswith('F'):
            self.algo = 'Fast'
        else:
            raise VaspIncarError('Unsupported ALGO value:{}'.format(self.algo))

        if self.lreal == False or self.lreal.startswith('F') or self.lreal == '.FALSE.':
            self.lreal = '.FALSE.'
        elif self.lreal == True or self.lreal.startswith('T') or self.lreal == '.TRUE.':
            self.lreal = '.TRUE.'
        else:
            str_type = type(self.lreal)
            str_value = '{}'.format(self.lreal)
            print(str_type,str_value)
            raise VaspIncarError('Unsupported LREAL value:{}'.format(self.lreal))

        str_out = self._fmt_section.format('ELECTRONIC SCF RELAXATION')
        str_out += self._fmt_arg.format(fmt.format('ALGO',self.algo),self._cmt_dict['ALGO'][self.algo])
        str_out += self._fmt_arg.format(fmt.format('PREC',self.prec),self._cmt_dict['PREC'][self.prec])
        str_out += self._fmt_arg.format(fmt.format('LREAL',self.lreal),self._cmt_dict['LREAL'][self.lreal])
        str_out += self._fmt_arg.format(fmt.format('EDIFF',self.ediff),self._cmt_dict['EDIFF'])
        str_out += self._fmt_arg.format(fmt.format('ENCUT',self.encut),self._cmt_dict['ENCUT'])
        str_out += self._fmt_arg.format(fmt.format('NELM',self.nelm),self._cmt_dict['NELM'])
        str_out += '\n'

        return str_out

    def _spin_polarization_to_string(self):
        fmt = "{} = {}"

        str_out = self._fmt_section.format('SPIN POLARIZATION CONFIGURATION')

        if self.ispin==1:
            str_out += self._fmt_arg.format(fmt.format('ISPIN',self.ispin),self._cmt_dict['ISPIN'][self.ispin])

        if self.ispin == 2:
            str_out += self._fmt_arg.format(fmt.format('ISPIN',self.ispin),self._cmt_dict['ISPIN'][self.ispin])

            if self.lorbit is not None:
                if self.lorbit < 10:
                    if self.rwigs is not None:
                        str_out += self.get_option_string('LORBIT',self.lorbit)
                        str_out += self.get_option_string('RWIGS',self.rwigs)
                    else:
                        if self.lorbit == 0:
                            self.lorbit = 10
                        elif self.lorbit == 1:
                            self.lorbit = 11
                        elif self.lorbit == 2:
                            self.lorbit = 12
                        elif self.lorbit == 5:
                            self.lorbit = 10
                        else:
                            raise VaspIncarError('')
                        str_out += self.get_option_string('LORBIT',self.lorbit)
                else:
                    str_out += self.get_option_string('LORBIT',self.lorbit)

            if self.magmom is not None:
                str_out += fmt.format('MAGMOM',self.magmom) + '\n'

        str_out += '\n'

        return str_out

    @DeprecationWarning
    def __spin_polarization_to_string(self):
        return self._spin_polarization_to_string()

    def __ionic_relaxation_to_string(self):
        fmt = "{} = {}"

        if (self.ibrion is None) and (self.isif is None):
            return ''

        # some default configuration for ibrion
        if self.ibrion is None:
            self.ibrion = 2

        # some default configuration for isif
        if self.isif is None:
            self.isif = 3

        # some default configuration for EDIFFG
        if self.ediffg is None:
            self.ediffg = -0.01 # ev/A - typical
        # some default configuration for POTIM
        if self.potim is None:
            if self.ibrion in [1,2,3]:
                self.potim = 0.5
            if self.ibrion in [5,6,7,8]:
                self.potim = 0.015

        # some default configuration for NSW
        if self.nsw is None:
            self.nsw = 40

        str_out = self._fmt_section.format('IONIC RELAXATION CONFIGURATION')
        str_out += self._fmt_arg.format(fmt.format('IBRION',self.ibrion),self._cmt_dict['IBRION'][self.ibrion])
        str_out += self._fmt_arg.format(fmt.format('ISIF',self.isif),self._cmt_dict['ISIF'][self.isif])
        str_out += self._fmt_arg.format(fmt.format('POTIM',self.potim),self._cmt_dict['POTIM'])
        str_out += self._fmt_arg.format(fmt.format('NSW',self.nsw),self._cmt_dict['NSW'])

        if self.ediffg < 0:
            str_out += self._fmt_arg.format(fmt.format('EDIFFG',self.ediffg),'force convergence requirements in ev A')
        else:
            str_out += self._fmt_arg.format(fmt.format('EDIFGG',self.ediffg),'energy convergence in eV')
        str_out += '\n'

        return str_out

    def __output_configuration_to_string(self):
        fmt = "{} = {}"

        if self.lwave in [True,'T','.TRUE.']:
            self.lwave = '.TRUE.'
        elif self.lwave in [False,'F','.FALSE.']:
            self.lwave = '.FALSE.'
        else:
            msg = "LWAVE tag cannot be {}({})".format(type(self.lwave),self.lwave)
            raise VaspIncarException(msg)

        if self.lcharg in [True,'T','.TRUE.']:
            self.lcharg = '.TRUE.'
        elif self.lcharg in [False,'F','.FALSE.']:
            self.lcharg = '.FALSE.'
        else:
            msg = "LCHARG tag cannot be {}({})".format(type(self.lcharg),self.lcharg)
            raise VaspIncarException(msg)

        if self.lvtot is [True,'T','.TRUE.']:
            self.lvtot = '.TRUE.'
        elif self.lvtot in [False,'T','.FALSE.']:
            self.lvtot= '.FALSE.'
        else:
            msg = "LVTOT tag cannot be {}({})".format(type(self.lwave),self.lvtot)
            raise VaspIncarException(msg)

        str_out = self._fmt_section.format('OUTPUT CONFIGURATION')
        str_out += self._fmt_arg.format(fmt.format('LWAVE',self.lwave),self._cmt_dict['LWAVE'][self.lwave])
        str_out += self._fmt_arg.format(fmt.format('LCHARG',self.lcharg),self._cmt_dict['LCHARG'][self.lcharg])
        str_out += self._fmt_arg.format(fmt.format('LVTOT',self.lvtot),self._cmt_dict['LVTOT'][self.lvtot])
        str_out += "\n"
        return str_out

# *****************************************************************************
# ****    SOME HELPER FUNCTIONS
# *****************************************************************************



class IncarBaseTags():
    tag_dictionary = OrderedDict()

    @classmethod
    def is_valid_option(cls, option):
        if option in cls.tag_dictionary:
            return True
        else:
            return False

    @classmethod
    def get_comment(self, option):
        try:
            return tag_dictionary[option]
        except KeyError:
            msg = "unknown option, {}".format(option)
            raise VaspIncarError(msg)

class IncarBaseFloatTag(IncarBaseTags):
    tag_name = 'fake tag'
    comment = 'fake comment'

    @classmethod
    def is_valid_option(cls, option):
        if any([
                isinstance(option,int),
                isinstance(option,float)
                ]):
            return True
        else:
            return False

    @classmethod
    def get_comment(cls,option):
        return cls.comment

class IstartTags(IncarBaseTags):

    tag_dictionary = OrderedDict([
        (0,'begin from scratch'),
        (1,'continuation job, constant energy cutoff'),
        (2,'continuation job, constant basis set'),
    ])

class IsymTags(IncarBaseTags):

    tag_dictionary = OrderedDict([
        (-1,'symmetry off'),
        (0,'symmetry_on'),
        (1,'symmetry_on'),
        (2,'symmetry_on, efficient symmetrization'),
        (3,'symmetry_on, only forces and stress tensor')
    ])

class SymprecTag(IncarBaseFloatTag):
    tag_name = 'SYMPREC'
    comment = 'determines how accurate positions must be'

class IchargTags(IncarBaseTags):
    tag_dictionary = OrderedDict([
        (0,'Calculate charge density from initial wave functions.'),
        (1,'Read the charge density from file CHGCAR'),
        (2,'Take superposition of atomic charge densities')
    ])

class IsmearTags(IncarBaseTags):
    tag_name = 'ISMEAR'
    tag_dictionary = OrderedDict([
        (-5,'tetrahedron method with Blochl corrections'),
        (-4,'tetrahedron method'),
        (0,'method of Gaussian smearing'),
        (1,'method of Methfessel-Paxton order 1'),
        (2,'method of Methfessel-Paxton order 2')
    ])

class SigmaTag(IncarBaseFloatTag):
    tag_name = 'SIGMA'
    comment = 'width of the smearing in eV.'

class NelmTag(IncarBaseFloatTag):
    tag_name = 'NELM'
    comment = 'maximum number of electronic SC'

class EncutTag(IncarBaseFloatTag):
    tag_name = 'ENCUT'
    comment = 'Cut-off energy for plane wave basis set in eV'

class EdiffTag(IncarBaseFloatTag):
    tag_name = 'EDIFF'
    comment = 'convergence condition for SC-loop in eV'

class EdiffgTag(IncarBaseFloatTag):
    tag_name = 'EDIFFG'
    comment_force_relaxation = 'force convergence requirements in ev A'
    comment_energy_relaxation = 'energy convergence in eV'

    @classmethod
    def get_comment(cls,option):
        return cls.comment
        if option == 0:
            msg = 'cannot select zero, must select a convergence value'
            raise ValueError(msg)
        elif self.ediffg < 0:
            return cls.comment_force_relaxation
        else:
            return cls.comment_energy_relaxation

class PrecTags(IncarBaseTags):
    tag_name = 'PREC'
    tag_dictionary = OrderedDict([
        ('Accurate', 'avoid wrap around errors'),
        ('High', 'avoid wrap around errors')
    ])

class AlgoTags(IncarBaseTags):
    tag_name = 'ALGO'
    tag_dictionary = OrderedDict([
        ('Normal', 'blocked Davidson iteration scheme'),
        ('VeryFast', 'RMM-DIIS'),
        ('Fast', 'blocked Davidson, followed by RMM_DIIS')
    ])

class LrealTags(IncarBaseTags):
    tag_name = 'LREAL'
    tag_dictionary = OrderedDict([
        ('.FALSE.', 'projection done in reciprocal space'),
        ('On', 'method of King-Smith, et al. Phys. Rev B 44, 13063 (1991).'),
        ('Auto', 'unpublished method of G. Kresse')
    ])

class LorbitTags(IncarBaseTags):
    tag_name = 'LORBIT'
    tag_dictionary = OrderedDict([
        (0, 'DOSCAR and PROCAR'),
        (1, 'DOSCAR and lm-decomposted PROCAR'),
        (2, 'DOSCAR, lm_decomposed PROCAR, phase factors'),
        (5, 'DOSCAR, PROCAR'),
        (10, 'DOSCAR, PROCAR'),
        (11, 'DOSCAR, lm-decomposed PROCAR'),
        (12, 'DOSCAR, lm-decomposed PROCAR, phase factors'),
    ])

class IspinTags(IncarBaseTags):
    tag_name = 'ISPIN'
    tag_dictionary = OrderedDict([
        (1, 'non-spin polarized calculations'),
        (2, 'spin polarized calculations')
    ])

class IBrionTags(IncarBaseTags):
    tag_name = 'IBRION'
    tag_dictionary = OrderedDict([
        (0, 'molecular dynamics'),
        (1, 'ionic relaxation by RMM-DIIS'),
        (2, 'ionic relaxation by CG'),
        (3, 'ionic relaxation by damped MD'),
        (5, 'phonons, by frozen ion, without symmetry'),
        (6, 'phonons, by frozen ion, with symmetry'),
        (7, 'phonons, by perturbation theory, no symmetry'),
        (8, 'phonons, by perturbtion theory, with symmetry')
    ])

class IsifTags(IncarBaseTags):
    tag_name = 'ISIF'
    tag_dictionary = OrderedDict([
        (2, 'relaxation, ions=T, cellshape=F, cellvolume=F'),
        (3, 'relaxation, ions=T, cellshape=T, cellvolume=T'),
        (4, 'relaxation, ions=T, cellshape=T, cellvolume=F'),
        (5, 'relaxation, ions=F, cellshape=T, cellvolume=F'),
        (6, 'relaxation, ions=F, cellshape=T, cellvolume=T'),
        (7, 'relaxation, ions=F, cellshape=F, cellvolume=T')
    ])

class EdiffTag(IncarBaseFloatTag):
    tag_name = 'EDIFF'
    comment = 'convergence condition for SC-loop in eV'

class PotimTag(IncarBaseFloatTag):
    tag_name = 'POTIM'
    comment = 'scaling factor in relaxation'

class NswTag(IncarBaseFloatTag):
    tag_name = 'NSW'
    comment = 'maximum number of ionic relaxation steps'

class LwaveTag(IncarBaseTags):
    tag_name = 'LWAVE'
    tag_dictionary = OrderedDict([
        ('.TRUE.', 'write WAVECAR'),
        ('.FALSE.', 'do not write WAVECAR')
    ])

class LchargTag(IncarBaseTags):
    tag_name = 'LCHARG'
    tag_dictionary = OrderedDict([
        ('.TRUE.', 'write CHGCR, write CHG'),
        ('.FALSE.', 'no CHGCAR, no CHG')
    ])

class LvtotTag(IncarBaseTags):
    tag_name = 'LVTOT'
    tag_dictionary = OrderedDict([
        ('.TRUE.', 'write LOCPOT'),
        ('.FALSE.', 'no LOCPOT')
    ])

class IncarComments():
    tag_dictionary = {
        'ISTART':IstartTags,
        'ISYM':IsymTags,
        'SYMPREC':SymprecTag
    }

    def get_comment(tag_name, tag_option):
        return tag_dictionary[tag_name].get_comment(tag_option)
