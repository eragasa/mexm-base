import os, shutil, pathlib
import re
import copy
import pypospack.crystal as crystal
import numpy as np

class Incar(object):

    def __init__(self, filename="INCAR"):
        """ object for dealing with input and output to VASP via INCAR file

        Args:
        filename (str): the filename of the INCAR file, default:'INCAR'
        """
        self.filename = filename

        self._fmt_section = '# {:*^78}\n'
        self._fmt_arg = '{:<30}! {}\n'
        self._cmt_dict = initialize_incar_comments()

        # default initialization of INCAR file
        self.system = 'automatically generated by mexm'
        self.__init_start_info()
        self.__init_density_of_states()
        self.__init_symmetry()
        self.__init_scf()
        self.__init_spin()
        self.__init_mixer()
        self.__init_ionic_relaxation()
        self.__init_output()

    def __init_start_info(self):
        self.istart=0
        self.icharg=0

    def __init_density_of_states(self):
        self.ismear=0
        self.sigma=0.2

    def __init_symmetry(self):
        self.isym = 2
        self.symprec = 1e-4

    def __init_scf(self):
        self.ediff = 1e-6 # convergece criteria in eV
        self.nelm = 40 # maximum number of SCF steps
        self.encut = 400 # energy cutoff
        self.prec = 'High'  # set avoid anti-aliasing errors
        self.lreal = 'False' # real space projectors are less accurate
        self.algo = 'Normal' # most robust operator

    def __init_spin(self):
        self.ispin=1
        self.lorbit=None
        self.rwigs=None
        self.magmom=None

    def __init_mixer(self):
        self.amix = None
        self.bmix = None
        self.amix_mag = None
        self.bmix_mag = None

    def __init_ionic_relaxation(self):
        self.ibrion = None
        self.isif = None
        self.ediffg = None
        self.nsw = None
        self.potim = None

    def __init_output(self):
        self.lwave = False
        self.lcharg = False
        self.lvtot = False

    @property
    def is_continue_job(self):
        "bool: True if continuation job"
        if self.istart != 0 or self.icharg!=0:
            return True
        else:
            return False

    def get_section_string(self, comment):
        str_out = '# {:*^78}\n'.format(comment)
        return str_out

    def get_option_string(self, option_flag, option_value):
        try:
            option_comment = self._cmt_dict[option_flag][option_value]
            str_out = '{:<30}! {}\n'.format(
                "{} = {}".format(option_flag, option_value),
                option_comment
            )
        except KeyError as e:
            str_out = '{} = {}\n'.format(option_flag, option_value)
        return str_out


    def write(self,filename=None):
        """write poscar file

        Args:
        filename (str): the filename of the poscar file,
        """

        if filename is not None:
           self.filename = filename
        f = open(self.filename,'w')
        f.write(self.to_string())
        f.close()

    def read(self,fname=None):
        if fname is not None:
            self.filename = fname
        f = open(self.filename)
        for line in f:
            if line.startswith('#'):
                # ignore comments
                pass
            elif line.strip() == '':
                # ignore blank lines
                pass
            else:
                args = [ line.strip().split('!')[0].split('=')[0].strip(),
                         line.strip().split('!')[0].split('=')[1].strip() ]
                if args[0] == 'ISTART':
                    self.istart = int(args[1])
                elif args[0] == 'ICHARG':
                    self.icharg = int(args[1])
                elif args[0] == 'ISPIN':
                    self.ispin = int(args[1])
                elif args[0] == 'MAGMOM':
                    self.magmom = args[1]
                elif args[0] == 'ISMEAR':
                    self.ismear = int(args[1])
                elif args[0] == 'SIGMA':
                    self.sigma = float(args[1])
                elif args[0] == 'ALGO':
                    self.algo = args[1]
                elif args[0] == 'EDIFF':
                    self.ediff = float(args[1])
                elif args[0] == 'ENCUT':
                    self.encut = float(args[1])
                elif args[0] == 'NELM':
                    self.nelm == int(args[1])
                elif args[0] == 'PREC':
                    self.prec = args[1]
                elif args[0] == 'EDIFFG':
                    self.ediffg = float(args[1])
                elif args[0] == 'IBRION':
                    self.ibrion = int(args[1])
                elif args[0] == 'ISIF':
                    self.isif = int(args[1])
                elif args[0] == 'POTIM':
                    self.potim = float(args[1])
                elif args[0] == 'NSW':
                    self.nsw = int(args[1])
                elif args[0] == 'SYSTEM':
                    self.system = args[1]
                elif args[0] == 'LWAVE':
                    self.lwave = args[1]
                elif args[0] == 'LCHARG':
                    self.lcharg = args[1]
                elif args[0] == 'LORBIT':
                    self.lorbit = int(args[1])
                elif args[0] == 'LVTOT':
                    self.lvtot = args[1]
                elif args[0] == 'LREAL':
                    self.lreal = args[1]
                elif args[0] == 'MAGMOM':
                    self.magmom = args[1]
                elif args[0] == 'ISYM':
                    self.isym = int(args[1])
                elif args[0] == 'SYMPREC':
                    self.symprec = float(args[1])
                elif args[0] == 'RWIGS':
                    self.rwigs = float(rwigs)
                elif args[0] == 'NPAR':
                    self.npar = int(args[1])
                elif args[0] == "AMIX":
                    self.amix = float(args[1])
                elif args[0] == 'BMIX':
                    self.bmix = float(args[1])
                elif args[0] == 'AMIX_MAG':
                    self.amix_mag = float(args[1])
                elif args[1] == 'BMIX_MAG':
                    self.bmix_mag = float(args[1])
                else:
                    err_msg = "pypospack does not support tag {}".format(args[0])
                    raise VaspIncarError(err_msg)

    def set_no_ionic_relaxation(self):
        self.ibrion = None
        self.isif = None

    def to_string(self):
        str_out = ''
        str_out += self.__system_information_to_string()
        str_out += self.__start_information_to_string()
        str_out += self.__dos_information_to_string()
        str_out += self.__sym_information_to_string()
        str_out += self.__scf_information_to_string()
        str_out += self.__spin_polarization_to_string()
        str_out += self._mixer_to_string()
        str_out += self.__ionic_relaxation_to_string()
        str_out += self.__output_configuration_to_string()
        return str_out

    def _mixer_to_string(self):

        mixing_tags = [self.amix, self.bmix, self.amix_mag, self.bmix_mag]
        if all([k is None for k in mixing_tags]):
            return ""
        else:
            str_out = self.get_section_string("MIXING")
            if self.amix is not None:
                str_out += self.get_option_string('AMIX',self.amix)
            if self.bmix is not None:
                str_out += self.get_option_string('BMIX',self.bmix)
            if self.amix_mag is not None:
                str_out += self.get_option_string('AMIX_MAG', self.amix_mag)
            if self.bmix_mag is not None:
                str_out += self.get_option_string('BMIX_MAG', self.bmix_mag)
            return str_out
    def __system_information_to_string(self):
        str_out = "SYSTEM = {}\n\n".format(self.system)
        return str_out

    def __start_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('STARTING INFORMATION')
        str_out += self._fmt_arg.format(fmt.format('ISTART',self.istart),self._cmt_dict['ISTART'][self.istart])
        str_out += self._fmt_arg.format(fmt.format('ICHARG',self.icharg),self._cmt_dict['ICHARG'][self.icharg])
        str_out += "\n"
        return str_out

    def __dos_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('DENSITY OF STATES')
        str_out += self._fmt_arg.format(fmt.format('ISMEAR',self.ismear),self._cmt_dict['ISMEAR'][self.ismear])
        str_out += self._fmt_arg.format(fmt.format('SIGMA',self.sigma),self._cmt_dict['SIGMA'])
        str_out += "\n"
        return str_out

    def __sym_information_to_string(self):
        fmt = "{} = {}"
        str_out = self._fmt_section.format('SYMMETRY')
        str_out += self._fmt_arg.format(fmt.format('ISYM',self.isym),self._cmt_dict['ISYM'][self.isym])
        str_out += self._fmt_arg.format(fmt.format('SYMPREC',self.symprec),self._cmt_dict['SYMPREC'])
        str_out += "\n"
        return str_out


    def __scf_information_to_string(self):
        fmt = "{} = {}"
        if self.algo.startswith('N'):
            self.algo = 'Normal'
        elif self.algo.startswith('V'):
            self.algo = 'VeryFast'
        elif self.algo.startswith('F'):
            self.algo = 'Fast'
        else:
            raise VaspIncarError('Unsupported ALGO value:{}'.format(self.algo))

        if self.lreal == False or self.lreal.startswith('F') or self.lreal == '.FALSE.':
            self.lreal = '.FALSE.'
        elif self.lreal == True or self.lreal.startswith('T') or self.lreal == '.TRUE.':
            self.lreal = '.TRUE.'
        else:
            str_type = type(self.lreal)
            str_value = '{}'.format(self.lreal)
            print(str_type,str_value)
            raise VaspIncarError('Unsupported LREAL value:{}'.format(self.lreal))

        str_out = self._fmt_section.format('ELECTRONIC SCF RELAXATION')
        str_out += self._fmt_arg.format(fmt.format('ALGO',self.algo),self._cmt_dict['ALGO'][self.algo])
        str_out += self._fmt_arg.format(fmt.format('PREC',self.prec),self._cmt_dict['PREC'][self.prec])
        str_out += self._fmt_arg.format(fmt.format('LREAL',self.lreal),self._cmt_dict['LREAL'][self.lreal])
        str_out += self._fmt_arg.format(fmt.format('EDIFF',self.ediff),self._cmt_dict['EDIFF'])
        str_out += self._fmt_arg.format(fmt.format('ENCUT',self.encut),self._cmt_dict['ENCUT'])
        str_out += self._fmt_arg.format(fmt.format('NELM',self.nelm),self._cmt_dict['NELM'])
        str_out += '\n'

        return str_out

    def _spin_polarization_to_string(self):
        fmt = "{} = {}"

        str_out = self._fmt_section.format('SPIN POLARIZATION CONFIGURATION')

        if self.ispin==1:
            str_out += self._fmt_arg.format(fmt.format('ISPIN',self.ispin),self._cmt_dict['ISPIN'][self.ispin])

        if self.ispin == 2:
            str_out += self._fmt_arg.format(fmt.format('ISPIN',self.ispin),self._cmt_dict['ISPIN'][self.ispin])

            if self.lorbit is not None:
                if self.lorbit < 10:
                    if self.rwigs is not None:
                        str_out += self.get_option_string('LORBIT',self.lorbit)
                        str_out += self.get_option_string('RWIGS',self.rwigs)
                    else:
                        if self.lorbit == 0:
                            self.lorbit = 10
                        elif self.lorbit == 1:
                            self.lorbit = 11
                        elif self.lorbit == 2:
                            self.lorbit = 12
                        elif self.lorbit == 5:
                            self.lorbit = 10
                        else:
                            raise VaspIncarError('')
                        str_out += self.get_option_string('LORBIT',self.lorbit)
                else:
                    str_out += self.get_option_string('LORBIT',self.lorbit)

            if self.magmom is not None:
                str_out += fmt.format('MAGMOM',self.magmom) + '\n'

        str_out += '\n'

        return str_out

    @DeprecationWarning
    def __spin_polarization_to_string(self):
        return self._spin_polarization_to_string()

    def __ionic_relaxation_to_string(self):
        fmt = "{} = {}"

        if (self.ibrion is None) and (self.isif is None):
            return ''

        # some default configuration for ibrion
        if self.ibrion is None:
            self.ibrion = 2

        # some default configuration for isif
        if self.isif is None:
            self.isif = 3

        # some default configuration for EDIFFG
        if self.ediffg is None:
            self.ediffg = -0.01 # ev/A - typical
        # some default configuration for POTIM
        if self.potim is None:
            if self.ibrion in [1,2,3]:
                self.potim = 0.5
            if self.ibrion in [5,6,7,8]:
                self.potim = 0.015

        # some default configuration for NSW
        if self.nsw is None:
            self.nsw = 40

        str_out = self._fmt_section.format('IONIC RELAXATION CONFIGURATION')
        str_out += self._fmt_arg.format(fmt.format('IBRION',self.ibrion),self._cmt_dict['IBRION'][self.ibrion])
        str_out += self._fmt_arg.format(fmt.format('ISIF',self.isif),self._cmt_dict['ISIF'][self.isif])
        str_out += self._fmt_arg.format(fmt.format('POTIM',self.potim),self._cmt_dict['POTIM'])
        str_out += self._fmt_arg.format(fmt.format('NSW',self.nsw),self._cmt_dict['NSW'])

        if self.ediffg < 0:
            str_out += self._fmt_arg.format(fmt.format('EDIFFG',self.ediffg),'force convergence requirements in ev A')
        else:
            str_out += self._fmt_arg.format(fmt.format('EDIFGG',self.ediffg),'energy convergence in eV')
        str_out += '\n'

        return str_out

    def __output_configuration_to_string(self):
        fmt = "{} = {}"

        if self.lwave in [True,'T','.TRUE.']:
            self.lwave = '.TRUE.'
        elif self.lwave in [False,'F','.FALSE.']:
            self.lwave = '.FALSE.'
        else:
            msg = "LWAVE tag cannot be {}({})".format(type(self.lwave),self.lwave)
            raise VaspIncarException(msg)

        if self.lcharg in [True,'T','.TRUE.']:
            self.lcharg = '.TRUE.'
        elif self.lcharg in [False,'F','.FALSE.']:
            self.lcharg = '.FALSE.'
        else:
            msg = "LCHARG tag cannot be {}({})".format(type(self.lcharg),self.lcharg)
            raise VaspIncarException(msg)

        if self.lvtot is [True,'T','.TRUE.']:
            self.lvtot = '.TRUE.'
        elif self.lvtot in [False,'T','.FALSE.']:
            self.lvtot= '.FALSE.'
        else:
            msg = "LVTOT tag cannot be {}({})".format(type(self.lwave),self.lvtot)
            raise VaspIncarException(msg)

        str_out = self._fmt_section.format('OUTPUT CONFIGURATION')
        str_out += self._fmt_arg.format(fmt.format('LWAVE',self.lwave),self._cmt_dict['LWAVE'][self.lwave])
        str_out += self._fmt_arg.format(fmt.format('LCHARG',self.lcharg),self._cmt_dict['LCHARG'][self.lcharg])
        str_out += self._fmt_arg.format(fmt.format('LVTOT',self.lvtot),self._cmt_dict['LVTOT'][self.lvtot])
        str_out += "\n"
        return str_out

# *****************************************************************************
# ****    SOME HELPER FUNCTIONS
# *****************************************************************************

tag_dictionary = {
    'ISTART':IstartTags
}


class IncarBaseTags():
    tag_dictionary = OrderedDict()

    @classmethod
    def is_valid_option(cls, option):
        if option in cls.tag_dictionary:
            return True
        else:
            return False

    @classmethod
    def get_comment(self, option):
        try:
            return tag_dictionary[option]
        except KeyError:
            msg = "unknown option, {}".format(option)
            raise VaspIncarError(msg)
class IstartTags(IncarBaseTags):

    tag_dictionary = [
        (0:'begin from scratch'),
        (1:'continuation job, constant energy cutoff'),
        (2:'continuation job, constant basis set'),
    ]


def initialize_incar_comments():
    comments_dict = {}
    comments_dict["SYSTEM"] = ''
    comments_dict["ISTART"] = {}
    comments_dict["ISTART"][0] = 'begin from scratch'
    comments_dict["ISTART"][1] = 'continuation job, constant energy cutoff'
    comments_dict["ISTART"][2] = 'continuation job, constant basis set'

    comments_dict["ISYM"] = {}
    comments_dict["ISYM"][-1] = 'symmetry off'
    comments_dict["ISYM"][0] = 'symmetry on'
    comments_dict["ISYM"][1] = 'symmetry on'
    comments_dict["ISYM"][2] = 'symmetry on, efficient symmetrization'
    comments_dict["ISYM"][3] = 'symmetry on, only forces and stress tensor'

    comments_dict["SYMPREC"] = 'determines how accurate positions must be'

    comments_dict["ICHARG"] = {}
    comments_dict["ICHARG"][0] = 'Calculate charge density from initial wave functions.'
    comments_dict["ICHARG"][1] = 'Read the charge density from file CHGCAR'
    comments_dict["ICHARG"][2] = 'Take superposition of atomic charge densities'

    comments_dict["ISMEAR"] = {}
    comments_dict["ISMEAR"][-5] = 'tetrahedron method with Blochl corrections'
    comments_dict["ISMEAR"][-4] = 'tetrahedron method'
    comments_dict["ISMEAR"][0] = 'method of Gaussian smearing'
    comments_dict["ISMEAR"][1] = 'method of Methfessel-Paxton order 1'
    comments_dict["ISMEAR"][2] = 'method of Methfessel-Paxton order 2'

    comments_dict["SIGMA"] = 'width of the smearing in eV.'

    comments_dict["NELM"] = 'maximum number of electronic SC'
    comments_dict["ENCUT"] = 'Cut-off energy for plane wave basis set in eV'
    comments_dict["EDIFF"] = 'convergence condition for SC-loop in eV'

    comments_dict["PREC"] = {}
    comments_dict["PREC"]['Accurate'] = 'avoid wrap around errors'
    comments_dict["PREC"]['High'] = 'avoid wrap around errors'

    comments_dict["ALGO"] = {}
    comments_dict["ALGO"]["Normal"] = 'blocked Davidson iteration scheme'
    comments_dict["ALGO"]["VeryFast"] = 'RMM-DIIS'
    comments_dict["ALGO"]["Fast"] = 'blocked Davidson, followed by RMM_DIIS'

    comments_dict["LREAL"] = {}
    comments_dict["LREAL"]['.FALSE.'] = 'projection done in reciprocal space'
    comments_dict["LREAL"]['On'] = 'method of King-Smith, et al. Phys. Rev B 44, 13063 (1991).'
    comments_dict["LREAL"]['Auto'] = 'unpublished method of G. Kresse'

    comments_dict['LORBIT'] = {}
    comments_dict['LORBIT'][0] = 'DOSCAR and PROCAR'
    comments_dict['LORBIT'][1] = 'DOSCAR and lm-decomposted PROCAR'
    comments_dict['LORBIT'][2] = 'DOSCAR,lm_decomposed PROCAR, phase factors'
    comments_dict['LORBIT'][5] = 'DOSCAR, PROCAR'
    comments_dict['LORBIT'][10] = 'DOSCAR, PROCAR'
    comments_dict['LORBIT'][11] = 'DOSCAR, lm-decomposed PROCAR'
    comments_dict['LORBIT'][12] = 'DOSCAR, lm-decomposed PROCAR, phase factors'

    comments_dict["ISPIN"] = {}
    comments_dict["ISPIN"][1] = 'non-spin polarized calculations'
    comments_dict["ISPIN"][2] = 'spin polarized calculations'

    comments_dict["IBRION"] = {}
    comments_dict["IBRION"][0] = 'molecular dynamics'
    comments_dict["IBRION"][1] = 'ionic relaxation by RMM-DIIS'
    comments_dict["IBRION"][2] = 'ionic relaxation by CG'
    comments_dict["IBRION"][3] = 'ionic relaxation by damped MD'
    comments_dict["IBRION"][5] = 'phonons, by frozen ion, without symmetry'
    comments_dict["IBRION"][6] = 'phonons, by frozen ion, with symmetry'
    comments_dict["IBRION"][7] = 'phonons, by perturbation theory, no symmetry'
    comments_dict["IBRION"][8] = 'phonons, by perturbtion theory, with symmetry'

    comments_dict["ISIF"] = {}
    comments_dict["ISIF"][2] = 'relaxation, ions=T, cellshape=F, cellvolume=F'
    comments_dict["ISIF"][3] = 'relaxation, ions=T, cellshape=T, cellvolume=T'
    comments_dict["ISIF"][4] = 'relaxation, ions=T, cellshape=T, cellvolume=F'
    comments_dict["ISIF"][5] = 'relaxation, ions=F, cellshape=T, cellvolume=F'
    comments_dict["ISIF"][6] = 'relaxation, ions=F, cellshape=T, cellvolume=T'
    comments_dict["ISIF"][7] = 'relaxation, ions=F, cellshape=F, cellvolume=T'

    comments_dict["POTIM"] = 'scaling factor in relaxation'
    comments_dict["NSW"] = 'maximum number of ionic relaxation steps'
    comments_dict["LWAVE"] = {}
    comments_dict["LWAVE"]['.TRUE.'] = 'write WAVECAR'
    comments_dict["LWAVE"]['.FALSE.'] = 'do not write WAVECAR'

    comments_dict["LCHARG"] = {}
    comments_dict["LCHARG"]['.TRUE.'] = 'write CHGCAR, write CHG'
    comments_dict["LCHARG"]['.FALSE.'] = 'no CHGCAR, no CHG'

    comments_dict['LVTOT'] = {}
    comments_dict['LVTOT']['.TRUE.'] = 'write LOCPOT'
    comments_dict['LVTOT']['.FALSE.'] = 'no LOCPOT'
    return comments_dict

# standard recommendations
potcar_std = { 'H':'H',
               'He':'He',
               'Li':'Li_sv',
               'Be':'Be',
               'B':'B',
               'C':'C'}
