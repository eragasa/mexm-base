from mexm.crystal import Atom

class SimulationCell(object):
    """A structural representation of a material system

    A structural system consists of a vector of lattice vector which forms the
    boundaries of the simulation cell, and an atomic basis of atoms defined in
    the direct coordinates of the lattice vectors.

    Args:
        obj (optional): if this argument is set then the this constructor acts
            as a copy constructor.  Will takse :obj:`ase.atoms.Atoms` and

    Attributes:
        comment (str): a descriptive description of the crystal structure
        atomic_basis (:obj:`list` of :obj:`pypospack.crystallography.Atoms`): a list
            of atoms contained within the crystal structure.
        a0 (float): a scaling factor which scales the lattice vectors by a0.
            Default is 1.
        H (numpy.ndarray): a numpy array containing the lattice vectors as
            row vectors.  Default is [[1,0,0],[0,1,0],[0,0,1]]
        ptol (:obj:`float`,optional): tolerance in which to find an atom/layer.
            Defaults to None.
        vacancies (:obj:`list` of :obj:`pypospack.crystal.Atoms`): a
            list of vacancy sites contained within the crystal structure.
        interstitials (:obj:`list` of :obj:`pypospack.crystal.Atoms`): a
            list of interstitial sites contained within the crystal structure.

    """
    def __init__(self, obj=None):
        self.ptol = 1e-3

        if obj is None:
            self._noncopy_init()
        elif isinstance(obj,ase.atoms.Atoms):
            self._copy_init_ase(obj)
        elif isinstance(obj,SimulationCell):
            self._copy_init_pypospack(obj)

    def _noncopy_init(self):
        self.comment = "generated by pypospack"
        self.ptol = 1.e-5 #tolerance in which to find an atom
        self.a0  = 1.0
        self.H = np.array([[1,0,0],
                           [0,1,0],
                           [0,0,1]])
        self.atomic_basis = []
        self.vacancies = []
        self.interstitials = []

    def _copy_init_pypospack(self,obj):
        self.comment = obj.comment
        self.a0 = obj.a0
        self.H = np.array(obj.H)

        self.atomic_basis = copy.deepcopy(obj.atomic_basis)
        self.vacancies = copy.deepcopy(obj.vacancies)
        self.interstitials = copy.deepcopy(obj.interstitials)

    def _copy_init_ase(self,obj):
        self.comment = "generated by pypospack from ase"
        self.a0 = 1.0
        self.H = np.copy(obj.cell)
        self.atomic_basis = []
        for a in obj:
            symbol = a.symbol
            position = cartesian2direct(a.position,self.H)
            for i in range(3):
                if position[i] < 0:
                    position[i] = 1 + position[i]
            self.atomic_basis.append(
                    Atom(symbol=symbol,position=position))
        self.vacancies = []
        self.interstitials = []

    @property
    def h1(self):
        """numpy.ndarray: which is the a1 lattice vector"""
        return np.array(self.H[0,:])

    @h1.setter
    def h1(self, h1):
        self.H[0,:] = np.array(h1)

    @property
    def h2(self):
        """numpy.array: which is the a2 lattice vector"""
        return np.array(self.H[1,:])

    @h2.setter
    def h2(self,h2):
        self.H[1,:] = np.array(h2)

    @property
    def h3(self):
        """numpy.array: this is the a3 lattice vector"""
        return np.array(self.H[2,:])

    @h3.setter
    def h3(self,h3):
        self.H[2,:] = np.array(h3)

    @property
    def a1(self):
        """float: the length of h1 lattice vector"""
        a0 = self.a0
        h1 = self.h1
        a1 = a0 * h1.dot(h1)**0.5
        return a1

    @property
    def a2(self):
        """float: the length of the h2 lattice vector"""
        a0 = self.a0
        h2 = self.h2
        a2 = a0 * h2.dot(h2)**0.5
        return a2

    @property
    def a3(self):
        """float: the length of the h3 lattice vector"""
        a0 = self.a0
        h3 = self.h3
        a3 = a0*h3.dot(h3)**0.5
        return a3

    @property
    def b1(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        a1 = np.array(self.h1)
        a2 = np.array(self.h2)
        a3 = np.array(self.h3)

        b1 = 2 * np.pi * np.cross(a2,a3) / np.dot(a1, np.cross(a2,a3))
        return b1

    @property
    def b2(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        a1 = np.array(self.h1)
        a2 = np.array(self.h2)
        a3 = np.array(self.h3)


        b2 = 2 * np.pi * np.cross(a3,a1) / np.dot(a2, np.cross(a3,a1))
        return b2

    @property
    def b3(self):
        """numpy.array: this is a 3x1 numpy array, in reciprocal space"""
        a1 = np.array(self.h1)
        a2 = np.array(self.h2)
        a3 = np.array(self.h3)

        b3 = 2 * np.pi * np.cross(a1,a2) / np.dot(a3, np.cross(a1,a2))
        return b3

    @property
    def n_atoms(self):
        """float: the number of atoms in the structure"""
        n_atoms = len(self.atomic_basis)
        return n_atoms

    @property
    def symbols(self):
        """list of str: a list of the symbols in the structure"""

        symbols = list(set([a.symbol for a in self.atomic_basis+self.interstitials]))
        return symbols

    def check_if_atom_exists_at_position(self,symbol,position):
        """determines if there is an atom at a position

        This code looks for atoms in the list of atoms in the atomic_basis.

        Returns:
            tuple: The first element if true in an atom exists at the location,
                False if it doesn't exist.   The second element is an int which
                indicates the index of the atom at that position.  The index is
                negative if it is the list of interstitials.
        """

        return_value = (False,None)
        # check to see if atom exists in the atomic basis
        for i,a in enumerate(self.atomic_basis):
            diff = [abs(position[i]-a.position[i]) for i in range(3)]
            if max(diff) < self.ptol:
                return_value = (True,i)

        return return_value

    def add_atom(self, symbol, position, magmom=0.):
        """add an atom to the structure

        Checks to see if an existing atom exists at the position we are trying
        to add an atom, then if the position is empty.  The atom is added then
        added to the list of interstitials.

        Args:
            symbol (str): the symbol of the atom to be added
            position (list): the position of the atom to be added
            magmom (float): magnetic moment of the atom

        Raises:
            ValueError: If an atom already exists in the position.
        """
        (is_atom_exists, __) = self.check_if_atom_exists_at_position(symbol,position)
        if is_atom_exists:
            err_msg = "Tried to add {} @ {} an atom already there\n"
            err_msg = err_msg.format(symbol,position)
            err_msg += 'atomic basis:\n'
            for i,a in enumerate(self.atomic_basis):
                err_msg += ",".join([str(i),a,a.symbol,a.position])
            raise ValueError(err_msg)
        else:
            self.atomic_basis.append(
                Atom(symbol,position,magmom=magmom)
            )

    def remove_atom(self, symbol, position):
        """ remove an atom from the structure

        This method checks for atom at the position, if an atom exists.  It is
        removed from the structure then the position is recorded as a vacancy.

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom

        """
        self.ptol = 1e-3
        for i,a in enumerate(self.atomic_basis):
            if (a.symbol == symbol):
                diff = [abs(position[j]-a.position[j]) for j in range(3)]
                if all([k < self.ptol for k in diff]):
                    del self.atomic_basis[i]
                    return
        err_msg = "Tried to remove {} @ {}, no atom found"
        err_msg = err_msg.format(symbol,position)
        raise ValueError(err_msg)

    def add_interstitial(self, symbol, position):
        """ add an interstitial to the atomic basis

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom
        """
        self.add_atom(symbol,position)
        self.interstitials.append([symbol,position])

    def add_vacancy(self, symbol, position):
        """ create a vacancy

        Creates a vacancy by removing an atom from the atomic basis

        Args:
            symbol (str): the symbol of the atom
            position (:obj:`list` of :obj:`float`): the position of the atom
        """
        self.remove_atom(symbol,position)
        self.vacancies.append([symbol,position])

    def get_number_of_atoms(self, symbol=None):
        if symbol is None:
            n_atoms = len(self._atoms)
        else:
            n_atoms = 0
            for atom in self.atomic_basis:
                if (atom.symbol == symbol):
                    n_atoms += 1
        return n_atoms

    def normalize_h_matrix(self):
        # change the h_matrix where the lattice parameter is 1.0
        for i in range(3):
            self.H[i,:] = self.H[i,:] * self.a0
        self.a0 = 1.0

        # calculate the norm of the h1 vector
        norm_h1 = self.a1
        # the norm of the h1 vector is the lattice parameter
        self.a0= norm_h1

        # normalize the h-matrix by the norm of h1
        for i in range(3):
            self.H[i,:] = self.H[i,:] / norm_h1

    def set_lattice_parameter(self, a0):
        # change the h_matrix where the lattice parameter is 1.0
        for i in range(3):
            self.H[i,:] = self.H[i,:] * self.a0

        self.a0 = a0
        for i in range(3):
            self.H[i,:] = self.H[i,:] / self.a0

    def atomic_basis_to_string(self):
        # print atomic basis
        str_n_cols = 5
        str_atomic_basis_header_fmt = "{:10}   {:10} {:10} {:10} {:10}\n"
        str_atomic_basis_row_fmt = "{:10} {:10.6f} {:10.6f} {:10.6f} {:10.6f}\n"
        str_out = str_atomic_basis_header_fmt.format('symbol','x','y','z','magmom')
        for a in self.atomic_basis:
            str_out += str_atomic_basis_row_fmt.format(
                a.symbol,
                a.position[0],
                a.position[1],
                a.position[2],
                a.magnetic_moment)
        return str_out

    def vacancies_to_string(self):
        print("vacancies:")
        print(self.vacancies)
        if self.vacancies == []:
            return ""
        else:
            str_out = ""
            return str_out

    def interstitials_to_string(self):
        print("interstitials:")
        print(self.interstitials)
        str_out = ""
        if self.interstitials == []:
            return ""
        else:
            str_out = ""
            return str_out

    def lattice_to_string(self):
        str_out += "a0 = {}\n".format(self.a0)
        str_out += "a1 = {:10.6f} {:10.6f} {:10.6f}\n".format(
            self.a0 * self.h1[0],
            self.a0 * self.h1[1],
            self.a0 * self.h1[2])
        str_out += "a2 = {:10.6f} {:10.6f} {:10.6f}\n".format(
            self.a0 * self.h2[0],
            self.a0 * self.h2[1],
            self.a0 * self.h2[2])
        str_out += "a3 = {:10.6f} {:10.6f} {:10.6f}\n".format(
            self.a0 * self.h3[0],
            self.a0 * self.h3[1],
            self.a0 * self.h3[2])

    def __str__(self):
        str_out = "lattice:"
        str_out += self.lattice_to_str()
        str_out += "atomic_basis:\n"
        str_out += self.atomic_basis_to_string()
        str_out += self.vacancies_to_string()
        str_out += self.interstitials_to_string()
        return str_out
